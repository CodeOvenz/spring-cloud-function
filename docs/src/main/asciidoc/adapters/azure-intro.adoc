:branch: master

=== Microsoft Azure Functions

The https://azure.microsoft.com[Azure] adapter, that allows to deploy and run Spring Cloud Functions as native Azure Java Functions.

The Azure impose an annotation-based https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-java[programming model] for defining the function's handler methods and their input and output types.
The  Azure's maven or gradle plugins are used to inspects the annotated class definitions to generate the necessary Azure Function binding files (such as function.json).
The annotations are just a type-safe way to configure your simple java function (function that has no awareness of Azure) to be recognized as Azure function.

The https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-adapters/spring-cloud-function-adapter-azure[spring-cloud-function-adapter-azure] extends the basic programming model and provides fully fledged Spring and Spring Cloud Function programming model support.
With the adapter you can build your, usual, Spring Cloud Function application and then auto-wire and use the required services from within your Azure handler methods.

TIP: For pure web based function applications, the https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-adapters/spring-cloud-function-adapter-azure-web[spring-cloud-function-adapter-azure-web] adapter allows replacing the Azure programming model completely with the familiar Spring Web programming model. You just build your Spring Web app, add the azure-web adapter dependency and the necessarily azure layout packaging. You can find more about the azure-web adapter [here]

==== Using the Azure Adapter

All you need to annotate the your class with `@Component` or `@Service` annotations, auto-wire the required Spring beans (or the https://docs.spring.io/spring-cloud-function/docs/current/reference/html/spring-cloud-function.html#_function_catalog_and_flexible_function_signatures[FunctionCatalog] when using Spring Cloud Function), define and configure your Azure function handler.

[source,java]
----
@SpringBootApplication
public class MyAzureFunction {

	public static void main(String[] args) {
		SpringApplication.run(MyAzureFunction.class, args);
	}

    /**
     * Plain Spring bean (not Spring Cloud Functions!)
     */
    @Autowired
    private Function<String, String> uppercase;

    /**
     * The FunctionCatalog leverages the Spring Cloud Function framework.
     */
    @Autowired
    private FunctionCatalog functionCatalog;

	@FunctionName("spring")
	public String plainBean( // <1>
			@HttpTrigger(name = "req", methods = { HttpMethod.GET,
					HttpMethod.POST }, authLevel = AuthorizationLevel.ANONYMOUS) HttpRequestMessage<Optional<String>> request,
			ExecutionContext context) {

		return this.uppercase.apply(request.getBody().get());
	}

	@FunctionName("scf")
    public String springCloudFunction( // <2>
            @HttpTrigger(name = "req", methods = { HttpMethod.GET,
                    HttpMethod.POST }, authLevel = AuthorizationLevel.ANONYMOUS) HttpRequestMessage<Optional<String>> request,
            ExecutionContext context) {

        // Use SCF composition. Composed functions are not just spring beans but SCF such.
        Function composed = this.functionCatalog.lookup("reverse|uppercase");

        return (String) composed.apply(request.getBody().get());
    }
}
----
Azure's programming-model uses the https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-java?tabs=bash%2Cconsumption#java-function-basics[@FunctionName] method annotation to identify the designated function handlers.
When invoked by a trigger (such as `@HttpTrigger`), functions process that trigger, and any other inputs, to produce one or more outputs.

TIP: Use the Java annotations included in the https://learn.microsoft.com/en-us/java/api/com.microsoft.azure.functions.annotation?view=azure-java-stable[com.microsoft.azure.functions.annotation.*] package to bind input and outputs to your methods.


<1> The `plainBean` method handler is mapped to an Azure function, called `spring`, and when executed is uses of the auto-wired `uppercase` spring bean to compute the result.
This demonstrates how to use "plain" Spring components in your Azure handlers.
<2> The `springCloudFunction` method handler is mapped to the `scf` Azure function and shows how to use Spring Cloud Function composition in your handles.

The actual Spring defined functions you're delegating to looks like this:

[source,java]
----
@Bean
public Function<String, String> uppercase() {
	return payload -> payload.toUpperCase();
}

@Bean
public Function<String, String> reverse() {
	return payload -> new StringBuilder(payload).reverse().toString();
}
----

In order to enable the Azure Function integration add the azure adapter dependency to your `pom.xml` or `build.gradle`
files:

====
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<dependencies>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-function-adapter-azure</artifactId>
		<version>4.0.3</version>
	</dependency>
</dependencies>
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
dependencies {
    implementation "org.springframework.cloud:spring-cloud-function-adapter-azure:4.0.3"
}

----
====

NOTE: version `4.0.0+` is required. Having the adapter on the classpath activates the Azure Java Worker integration.

===== Accessing Azure ExecutionContext

Some time there is a need to access the target execution context provided by the Azure runtime in the form of `com.microsoft.azure.functions.ExecutionContext`.
For example one of such needs is logging, so it can appear in the Azure console.

For that purpose the `AzureFunctionUtil.enhanceInputIfNecessary` allow you to add an instance of the `ExecutionContext` as a Message header so you can retrieve it via `executionContext` key.

[source,java]
----
@FunctionName("ditest")
public String execute(
		@HttpTrigger(name = "req", methods = { HttpMethod.GET,
				HttpMethod.POST }, authLevel = AuthorizationLevel.ANONYMOUS) HttpRequestMessage<Optional<String>> request,
		ExecutionContext context) {

    Message message = (Message) AzureFunctionUtil.enhanceInputIfNecessary(request.getBody().get(), context);

	return this.uppercase.apply(message);
}
----

now you can retrieve it via the via `executionContext` key.

[source,java]
----
@Bean
public Function<Message<String>, String> uppercase(JsonMapper mapper) {
	return message -> {
		String value = message.getPayload();
		ExecutionContext context = (ExecutionContext) message.getHeaders().get("executionContext");
		. . .
	}
}
----

==== Azure JAR Layout

You don't need the Spring Cloud Function Web at runtime in Azure, so you can exclude this before you create the JAR you deploy to Azure, but it won't be used if you include it, so it doesn't hurt to leave it in.
A function application on Azure is an archive generated either by the Maven (`azure-functions-maven-plugin`) or the  Gradle(`azure-functions-gradle-plugin`) plugins.
The function lives in the JAR file generated by this project.

The sample creates it as an executable jar, using the thin layout, so that Azure can find the handler classes. If you prefer you can just use a regular flat JAR file.
The dependencies should *not* be included.

==== Build file setup

In order to run Spring Cloud Function applications on Microsoft Azure, you have to use Maven or Gradle plugins offered by Azure.

Provide the Azure-specific configuration for your application, specifying the `resourceGroup`, `appName` and other optional properties.
More information about the runtime configurations: https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-java?tabs=bash%2Cconsumption#java-versions[Java Versions], https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-java?tabs=bash%2Cconsumption#specify-the-deployment-os[Deployment OS].

Sample Azure Function (Maven/Gradle) configuration would like like:

====
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<plugin>
	<groupId>com.microsoft.azure</groupId>
	<artifactId>azure-functions-maven-plugin</artifactId>
	<version>1.22.0 or higher</version>

	<configuration>
		<appName>YOUR-AZURE-FUNCTION-APP-NAME</appName>
		<resourceGroup>YOUR-AZURE-FUNCTION-RESOURCE-GROUP</resourceGroup>
		<region>YOUR-AZURE-FUNCTION-APP-REGION</region>
		<appServicePlanName>YOUR-AZURE-FUNCTION-APP-SERVICE-PLANE-NAME</appServicePlanName>
		<pricingTier>YOUR-AZURE-FUNCTION-PRICING-TIER</pricingTier>

		<hostJson>${project.basedir}/src/main/resources/host.json</hostJson>

		<runtime>
			<os>linux</os>
			<javaVersion>11</javaVersion>
		</runtime>

		<funcPort>7072</funcPort>

		<appSettings>
			<property>
				<name>FUNCTIONS_EXTENSION_VERSION</name>
				<value>~4</value>
			</property>
		</appSettings>
	</configuration>
	<executions>
		<execution>
			<id>package-functions</id>
			<goals>
				<goal>package</goal>
			</goals>
		</execution>
	</executions>
</plugin>
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
plugins {
    id "com.microsoft.azure.azurefunctions" version "1.11.0"
	// ...
}

apply plugin: "com.microsoft.azure.azurefunctions"

azurefunctions {
	appName = 'YOUR-AZURE-FUNCTION-APP-NAME'
    resourceGroup = 'YOUR-AZURE-FUNCTION-RESOURCE-GROUP'
    region = 'YOUR-AZURE-FUNCTION-APP-REGION'
    appServicePlanName = 'YOUR-AZURE-FUNCTION-APP-SERVICE-PLANE-NAME'
    pricingTier = 'YOUR-AZURE-FUNCTION-APP-SERVICE-PLANE-NAME'
    runtime {
      os = 'linux'
      javaVersion = '11'
    }
    auth {
      type = 'azure_cli'
    }
    appSettings {
      FUNCTIONS_EXTENSION_VERSION = '~4'
    }
}
----
====

The complete plugin documentation is available at the https://github.com/microsoft/azure-maven-plugins/tree/develop/azure-functions-maven-plugin[Azure Maven] and https://github.com/microsoft/azure-gradle-plugins/tree/master/azure-functions-gradle-plugin[Azure Gradle] repositories.

Next you must specify the `Start-Class` or `Main-Class` to point to your application main class.

====
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<properties>
	<start-class>YOUR APP MAIN CLASS</start-class>
	...
</properties>
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
jar {
    manifest {
        attributes(
            "Main-Class": "YOUR APP MAIN CLASS"
        )
    }
}
----
====

IMPORTANT: The main class provided must be annotated by `SpringBootApplication` or `SpringBootConfiguration` annotation.


You will also have to ensure that the files to be scanned by the plugin can be found in the Azure functions staging directory (see the https://github.com/microsoft/azure-maven-plugins[plugin repository] for more details on the staging directory and it's default location).

Add the `host.json` configuration file:

[source,json]
----
{
	"version": "2.0",
	"extensionBundle": {
		"id": "Microsoft.Azure.Functions.ExtensionBundle",
		"version": "[3.*, 4.0.0)"
	}
}
----

TIP: If the file is not in the project top folder you need to configure your plugins accordingly (like `hostJson` maven attribute).


Here is a list of various Spring Cloud Function Azure Adapter samples you can explore:

- https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-azure-http-trigger[HTTP Trigger (Maven)]
- https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-azure-http-trigger-gradle[ HTTP Trigger (Gradle)]
- https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-azure-blob-trigger[Blob Trigger (Maven)]
- https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-azure-timer-trigger[Timer Trigger (Maven)]
- https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-azure-kafka-trigger[ Kafka Trigger & Output Binding (Maven)].

==== Build

====
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
./mvnw -U clean package
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
./gradlew azureFunctionsPackage
----
====

==== Running locally

To run locally on top of `Azure Functions`, and to deploy to your live Azure environment, you will need `Azure Functions Core Tools` installed along with the Azure CLI (see https://docs.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-java?tabs=bash%2Cazure-cli%2Cbrowser#configure-your-local-environment[here]).
For some configuration you would need the https://learn.microsoft.com/en-us/azure/storage/common/storage-use-emulator[Azurite emulator] as well.

Then run the sample:

====
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
./mvnw azure-functions:run
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
./gradlew azureFunctionsRun
----
====

==== Running on Azure

Make sure you are logged in your Azure account.

----
az login
----

and deploy

====
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
./mvnw azure-functions:deploy
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
./gradlew azureFunctionsDeploy
----
====

==== Debug locally

Run the function in debug mode.

----
./mvnw azure-functions:run -DenableDebug
----

Alternatively and the `JAVA_OPTS` value to your `local.settings.json` like this:

[source,json]
----
{
	"IsEncrypted": false,
	"Values": {
		...
		"FUNCTIONS_WORKER_RUNTIME": "java",
		"JAVA_OPTS": "-Djava.net.preferIPv4Stack=true -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=127.0.0.1:5005"
	}
}
----


VS Code remote debug configuration:

[source,xml]
----
{
"version": "0.2.0",
"configurations": [
	{
		"type": "java",
		"name": "Attach to Remote Program",
		"request": "attach",
		"hostName": "localhost",
		"port": "5005"
	},
	...
]
}
----

=== Microsoft Azure Functions Web

For pure web based function applications, the https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-adapters/spring-cloud-function-adapter-azure-web[spring-cloud-function-adapter-azure-web] adapter allows replacing the Azure programming model completely with the familiar Spring Web programming model. You just build your Spring Web app, add the azure-web adapter dependency and the necessarily azure layout packaging.

The `spring-cloud-function-adapter-azure-web` requires the same package layout and build/deployment steps as the `spring-cloud-function-adapter-azure`.

=== (Legacy) FunctionInvoker integration

WARNING: The legacy `FunctionInvoker` programming model is deprecated and will not be supported going forward.

For additional documentation and samples about the Function Integration approach follow the https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-azure/[azure-sample] README and code.
